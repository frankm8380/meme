<div id="container">
	<!-- Define all buttons in one place (Hidden) -->
	<div id="allButtons" style="display: none;">
		<button id="readBtn" class="btn btn-read">üìñ Read</button>
		<button id="createBtn" class="btn btn-create">üé® Create</button>
		<button id="uploadBtn" class="btn btn-upload">üì§ Upload</button>
		<button id="sendBtn" class="btn btn-send">‚úâÔ∏è Send</button>
		<button id="donateBtn" class="btn btn-donate">üí∞ Donate</button>
		<button id="startCameraBtn" class="btn btn-start">üé• Start Camera</button>
		<button id="stopCameraBtn" class="btn btn-stop">üõë Stop Camera</button>
		<button id="retryBtn" class="btn btn-retry">üîÑ Restart</button>
		<button id="saveBtn" class="btn btn-save">‚úÖ Save</button>
		<button id="editBtn" class="btn btn-edit">‚úèÔ∏è Edit</button>
		<button id="newBtn" class="btn btn-new-meme">üÜï New</button>
		<button id="shareBtn" class="btn btn-share">üì§ Share</button>
		<button id="doneBtn" class="btn btn-done">‚úÖ Done</button>
		<button id="backBtn" class="btn btn-back">‚¨ÖÔ∏è Back</button>
	</div>

	<!-- Top Floating Result Container -->
	<div id="resultContainer" class="glassmorphism">
		<p id="result">What can I do on this page?</p>
		<div id="topButtonsContainer" class="button-row"></div>
	</div>

	<!-- Meme Image Container -->
	<div class="image-controls-wrapper">
		<div class="image-container">
			<canvas id="memeCanvas" style="display: none;"></canvas>
		</div>
	</div>

	<!-- Bottom Floating Result Container -->
	<div id="bottomResultContainer" class="glassmorphism">
		<p id="bottomResult">Ready to proceed?</p>
		<div id="bottomButtonsContainer" class="button-row"></div>
	</div>

	<!-- Movable Popup Meme Editor -->
	<div id="memeEditorPopup" class="meme-popup hidden">
		<div class="editor-header">
			<h2 class="editor-label">Meme Editor</h2>
			<button id="closeEditorBtn" class="btn-icon" onclick="toggleMemeEditor()">‚úñ</button>
		</div>

		<div class="dropdown-wrapper">
			<div class="controls-container">
				<label for="topText">üìù Top:</label>
				<select id="topText" onchange="updateMemeText()"></select>
			</div>
			<div class="controls-container">
				<label for="bottomText">üìù Bottom:</label>
				<select id="bottomText" onchange="updateMemeText()"></select>
			</div>
		</div>

		<div class="controls-row-web">
			<div class="controls-container">
				<label for="textColor">üé® Color:</label>
				<input type="color" id="textColor" value="#ffffff" oninput="updateColor(); updateMemeText();">
			</div>
			<div class="controls-container">
				<label for="includeDisclaimer">üìú Disclaimer:</label>
				<input type="checkbox" id="includeDisclaimer" checked onchange="updateMemeText()">
			</div>
		</div>
	</div>
</div>

<!-- Read Modal -->
<div id="readModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('readModal')">&times;</span>
		<h2>üìñ Read</h2>
		<p>Here you can read about how to use the meme editor.</p>
		<button class="modal-close-button" onclick="closeModal('readModal')">Close</button>
	</div>
</div>

<!-- Create Modal -->
<div id="createModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('createModal')">&times;</span>
		<h2>üé® Create</h2>
		<p>Use this feature to design your meme.</p>
		<label>
			<input type="checkbox" id="skipCreateModal" onchange="saveModalPreference('createModal')">
			Do not show again
		</label>
		<button class="modal-close-button" onclick="closeModal('createModal')">Close</button>
	</div>
</div>

<!-- Save Modal -->
<div id="saveModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('saveModal')">&times;</span>
		<h2>üì§ Save</h2>
		<p>Save your meme.</p>
		<button class="modal-close-button" onclick="closeModal('saveModal')">Close</button>
	</div>
</div>

<!-- Edit Modal -->
<div id="editModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('editModal')">&times;</span>
		<h2>üì§ Edit</h2>
		<p>Edit your meme.</p>
		<button class="modal-close-button" onclick="closeModal('editModal')">Close</button>
	</div>
</div>

<!-- Upload Modal -->
<div id="uploadModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('uploadModal')">&times;</span>
		<h2>üì§ Upload</h2>
		<p>Upload your meme to the gallery.</p>
		<button class="modal-close-button" onclick="closeModal('uploadModal')">Close</button>
	</div>
</div>

<!-- Send Modal -->
<div id="sendModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('sendModal')">&times;</span>
		<h2>‚úâÔ∏è Send</h2>
		<p>Send your meme.</p>
		<button class="modal-close-button" onclick="closeModal('sendModal')">Close</button>
	</div>
</div>

<!-- Share Modal -->
<div id="shareModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('shareModal')">&times;</span>
		<h2>‚úâÔ∏è Send</h2>
		<p>Share your meme.</p>
		<button class="modal-close-button" onclick="closeModal('shareModal')">Close</button>
	</div>
</div>

<!-- Donate Modal -->
<div id="donateModal" class="modal">
	<div class="modal-content">
		<span class="close" onclick="closeModal('donateModal')">&times;</span>
		<h2>üí∞ Donate</h2>
		<p>Support the project by donating.</p>
		<button class="modal-close-button" onclick="closeModal('donateModal')">Close</button>
	</div>
</div>

<script>
	
// üîÑ meme-state-machine.js

/** üè∑Ô∏è Define Constants for Readability */
const BUTTONS = {
    READ: "readBtn",
    CREATE: "createBtn",
    UPLOAD: "uploadBtn",
    SEND: "sendBtn",
    DONATE: "donateBtn",
    START_CAMERA: "startCameraBtn",
    STOP_CAMERA: "stopCameraBtn",
    RETRY: "retryBtn",
    SAVE: "saveBtn",
    EDIT: "editBtn",
    SHARE: "shareBtn",
    NEW: "newBtn",
    DONE: "doneBtn",
    BACK: "backBtn"
};

/** üé≠ Define State Identifiers */
const STATE = {
    INITIAL: 1,
    READ: 2,
    CREATE: 3,
    CREATE_MODE: 3.1,
    CAMERA_RUNNING: 4,
    CAMERA_STOPPED: 4.1,
    GESTURE_DETECTED: 5,
    EDIT: 6,
    EDIT_MODE: 6.1,
    SAVE: 7,
    SAVE_MODE: 7.1,
    UPLOAD: 8,
    UPLOAD_MODE: 8.1,
    SEND: 9,
    SEND_MODE: 9.1,
    SHARE: 10,
    SHARE_MODE: 10.1,
    DONATE: 11
};


/**
 * üèóÔ∏è State Factory Function (Easier to Maintain & Modify)
 */
function createState({ 
    name, 
    topButtons = [], 
    bottomButtons = [], 
    modal = null, 
    onEnter = null, 
    topVisible = true,  
    bottomVisible = true,
    nextState = null, // ‚úÖ Define the next state after closing a modal
    positionTop = null // ‚úÖ Define top container positioning ("top" or "default")
}) {
    return { name, topButtons, bottomButtons, modal, onEnter, topVisible, bottomVisible, nextState, positionTop };
}

/** üìå Define State Transitions */
const states = {
    [STATE.INITIAL]: createState({
        name: "Initial",
        topButtons: [BUTTONS.READ, BUTTONS.CREATE, BUTTONS.DONATE],
        bottomButtons: [BUTTONS.BACK],
        topVisible: true,  // ‚úÖ Explicitly show top container
        bottomVisible: true,
        positionTop: "default"  // ‚úÖ Follows after any header (default)
    }),
    [STATE.READ]: createState({
        name: "Read Modal",
        modal: "readModal",
        topVisible: false, // ‚úÖ Hide top container for modals
        bottomVisible: false
    }),
    [STATE.CREATE]: createState({
        name: "Create Modal",
        modal: "createModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.CAMERA_RUNNING, // ‚úÖ When closed, transition to CREATE_MODE
        positionTop: "top"  // ‚úÖ Moves top container to very top (adjust for WP admin bar)
    }),
    [STATE.CREATE_MODE]: createState({
        name: "Create Mode",
        bottomButtons: [BUTTONS.START_CAMERA, BUTTONS.BACK],
        topVisible: true,  // ‚úÖ Ensure top container is visible
        bottomVisible: true,
        positionTop: "top"  // ‚úÖ Moves top container to very top (adjust for WP admin bar)
    }),
    [STATE.CAMERA_RUNNING]: createState({
        name: "Camera Running",
        bottomButtons: [BUTTONS.STOP_CAMERA, BUTTONS.EDIT, BUTTONS.BACK],
        onEnter: startCamera,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.CAMERA_STOPPED]: createState({
        name: "Camera Stopped",
        bottomButtons: [BUTTONS.START_CAMERA, BUTTONS.BACK],
        onEnter: stopCamera,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.GESTURE_DETECTED]: createState({
        name: "Gesture Detected",
        bottomButtons: [BUTTONS.EDIT, BUTTONS.RETRY, BUTTONS.SAVE, BUTTONS.BACK],
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.EDIT]: createState({
        name: "Edit Modal",
        modal: "editModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.EDIT_MODE // ‚úÖ When closed, transition to EDIT_MODE
    }),
    [STATE.EDIT_MODE]: createState({
        name: "Meme Editing Mode",
        onEnter: toggleMemeEditor,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.SAVE]: createState({
        name: "Save Modal",
        modal: "saveModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.SAVE_MODE // ‚úÖ When closed, transition to SAVE_MODE
    }),
    [STATE.SAVE_MODE]: createState({
        name: "Meme Saved",
        bottomButtons: [BUTTONS.UPLOAD, BUTTONS.SEND, BUTTONS.SHARE, BUTTONS.DONATE, BUTTONS.BACK],
        onEnter: saveMeme,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.UPLOAD]: createState({
        name: "Upload Modal",
        modal: "uploadModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.UPLOAD_MODE // ‚úÖ When closed, transition to UPLOAD_MODE
    }),
    [STATE.UPLOAD_MODE]: createState({
        name: "Meme Uploaded",
        bottomButtons: [BUTTONS.SEND, BUTTONS.SHARE, BUTTONS.DONATE, BUTTONS.BACK],
        onEnter: uploadMeme,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.SEND]: createState({
        name: "Send Modal",
        modal: "sendModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.SEND_MODE // ‚úÖ When closed, transition to SEND_MODE
    }),
    [STATE.SEND_MODE]: createState({
        name: "Meme Sent",
        bottomButtons: [BUTTONS.UPLOAD, BUTTONS.SHARE, BUTTONS.DONATE, BUTTONS.BACK],
        onEnter: sendMeme,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.SHARE]: createState({
        name: "Share Modal",
        modal: "shareModal",
        topVisible: false,
        bottomVisible: false,
        nextState: STATE.SHARE_MODE // ‚úÖ When closed, transition to SHARE_MODE
    }),
    [STATE.SHARE_MODE]: createState({
        name: "Meme Sent",
        bottomButtons: [BUTTONS.UPLOAD, BUTTONS.SEND, BUTTONS.DONATE, BUTTONS.BACK],
        onEnter: shareMeme,
        topVisible: true,
        bottomVisible: true
    }),
    [STATE.DONATE]: createState({
        name: "Donate Modal",
        modal: "donateModal",
        topVisible: false,
        bottomVisible: false
    })
};

/** üîÑ Reverse Map for Button Actions */
const buttonStateMap = {
    [BUTTONS.READ]: STATE.READ,
    [BUTTONS.CREATE]: STATE.CREATE,
    [BUTTONS.UPLOAD]: STATE.UPLOAD,
    [BUTTONS.SEND]: STATE.SEND,
    [BUTTONS.DONATE]: STATE.DONATE,
    [BUTTONS.START_CAMERA]: STATE.CAMERA_RUNNING,
    [BUTTONS.STOP_CAMERA]: STATE.CAMERA_STOPPED,
    [BUTTONS.RETRY]: STATE.CREATE,
    [BUTTONS.SAVE]: STATE.SAVE,
    [BUTTONS.EDIT]: STATE.EDIT,
    [BUTTONS.SHARE]: STATE.SHARE,
    [BUTTONS.NEW]: STATE.CREATE,
    [BUTTONS.DONE]: STATE.INITIAL,
    [BUTTONS.BACK]: STATE.INITIAL
};
	
/**
 * üîÑ Updates UI Based on State
 */
function updateUI(state) {
    console.log(`üîÑ Updating UI for state: ${state.name}`);

    const topContainer = document.getElementById("resultContainer");
    const bottomContainer = document.getElementById("bottomResultContainer");

    if (!topContainer || !bottomContainer) {
        console.error("‚ùå UI containers not found in DOM.");
        return;
    }

    // Default visibility unless explicitly hidden
    const topShouldBeVisible = state.topVisible !== false;
    const bottomShouldBeVisible = state.bottomVisible !== false;

    console.log(`üìå Showing/Hiding containers... Top: ${topShouldBeVisible}, Bottom: ${bottomShouldBeVisible}`);
    topContainer.style.display = topShouldBeVisible ? "block" : "none";
    bottomContainer.style.display = bottomShouldBeVisible ? "block" : "none";

   // ‚úÖ Adjust top container position when transitioning states
    if (state.positionTop) {
		positionTopContainerBelowHeader = state.positionTop !== "top"; // If "top", set false (move to top)
        console.log(`This state has a positionTop: ${state.positionTop}`);
        adjustResultContainerPosition();
    }

    // üîΩ Function to update buttons dynamically üîΩ
    function updateButtons(location, buttons) {
        const container = document.getElementById(location === "top" ? "topButtonsContainer" : "bottomButtonsContainer");
        const allButtonsContainer = document.getElementById("allButtons");

        if (!container || !allButtonsContainer) {
            console.error(`‚ùå Missing container(s) for buttons: ${location}`);
            return;
        }

        // Clear existing buttons
        container.innerHTML = "";

        buttons.forEach(buttonId => {
            let button = allButtonsContainer.querySelector(`#${buttonId}`);

            if (button) {
                let clonedButton = button.cloneNode(true);
                clonedButton.addEventListener("click", () => {
                    console.log(`üñ± Click detected on: ${buttonId}, transitioning state.`);
                    changeState(buttonStateMap[buttonId] || 1);
                });

                container.appendChild(clonedButton);
            } else {
                console.warn(`‚ö†Ô∏è Button not found in #allButtons: ${buttonId}. Check for missing buttons.`);
            }
        });
    }

    updateButtons("top", state.topButtons || []);
    updateButtons("bottom", state.bottomButtons || []);
}


/**
 * üîÄ Changes State in the State Machine
 */
function changeState(newState) {
    if (!states[newState]) {
        console.error(`‚ùå Invalid state: ${newState}`);
        return;
    }

    // Store previous state when not in a modal
    if (!states[newState].modal) {
        previousState = newState;
    }

    console.log(`üîÄ Changing state from ${currentState} to ${newState}`);
    currentState = newState;

    // Automatically call `onEnter` function if defined
    if (states[newState].onEnter) {
        console.log(`‚ö° Executing onEnter function for state: ${newState}`);
        states[newState].onEnter();
    } else if (states[newState].modal) {
        // ‚úÖ Open modal if this state requires one
        let modalId = states[newState].modal;
        
        if (localStorage.getItem(`skip_${modalId}`) === "true") {
            console.log(`üö´ Skipping modal: ${modalId} (User preference)`);       
            afterModalClose(modalId);
            return;
        }

        let modal = document.getElementById(modalId);
        if (!modal) {
            console.error(`‚ùå Modal not found: ${modalId}`);
            return;
        }

        console.log(`üìå State machine opening modal: ${modalId}`);
        openModal(modalId);

        // üïµÔ∏è‚Äç‚ôÇÔ∏è Watch for modal closing
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.attributeName === "style" && window.getComputedStyle(modal).display === "none") {
                    console.log(`üõë Detected modal close: ${modalId}`);
                    observer.disconnect();
                    afterModalClose(modalId);
                }
            });
        });

        observer.observe(modal, { attributes: true });
    }

    // ‚úÖ UI updates (including buttons) are now handled in one place
    updateUI(states[currentState]);
}
	
/**
 * üîÑ Handles Skipped Modal (User Chose "Do not show again")
 */
function afterModalClose(modalId) {
    console.log("üîÑ Handling closed modal: " + modalId);

    let resultContainer = document.getElementById("resultContainer");
    let bottomContainer = document.getElementById("bottomResultContainer");
    if (resultContainer && bottomContainer) {
      // Get the current state that owns this modal
      let currentState = Object.values(states).find(state => state.modal === modalId);

      // Determine next state (if defined), otherwise go back to previous state
      let nextState = currentState?.nextState || previousState;

      console.log("üîÑ Transitioning to state: " + nextState);
      changeState(nextState);
	}
}
	  
// stuff to do once the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
	// Page Load Configuration
	const path = window.location.pathname.toLowerCase();
	const pageTitle = document.title.toLowerCase();
	loadConfiguration(path, pageTitle);

	const memeEditor = document.getElementById("memeEditorPopup");
	let isDragging = false;
	let offsetX, offsetY;

	// Drag and Move Meme Editor
	if (memeEditor) {
		memeEditor.addEventListener("mousedown", (e) => {
			isDragging = true;
			offsetX = e.clientX - memeEditor.getBoundingClientRect().left;
			offsetY = e.clientY - memeEditor.getBoundingClientRect().top;
			memeEditor.classList.add("dragging");
		});

		document.addEventListener("mousemove", (e) => {
			if (!isDragging) return;
			memeEditor.style.left = (e.clientX - offsetX) + "px";
			memeEditor.style.top = (e.clientY - offsetY) + "px";
		});

		document.addEventListener("mouseup", () => {
			isDragging = false;
			memeEditor.classList.remove("dragging");
		});
	}
	// Meme Canvas Initialization
	const memeCanvas = document.getElementById("memeCanvas");
	if (memeCanvas) {
		defaultCanvasWidth = memeCanvas.width;
		defaultCanvasHeight = memeCanvas.height;
		// Ensure canvas starts hidden until adjusted
		memeCanvas.style.display = "none";
		console.log("üìè Saved default memeCanvas size: " + defaultCanvasWidth + "x" + defaultCanvasHeight);
	}
	
	// Initialize UI based on the current state
	updateUI(states[currentState]);

	// Attach event listeners dynamically
	Object.keys(buttonStateMap).forEach(btn => {
		let button = document.getElementById(btn);
		if (button) {
			button.addEventListener("click", () => {
				console.log("üñ± Click detected on: " + btn + ", changing state to " + buttonStateMap[btn]);
				changeState(buttonStateMap[btn]);
			});
		} else {
			console.warn("‚ö†Ô∏è Button missing in DOM at load: " + btn);
		}
	});

	// Ensure canvas resizes properly on window resize
	let resizeTimeout;
	window.addEventListener("resize", () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(() => {
			const video = document.getElementById("webcam");
			if (video) adjustMemeCanvasSize(video);
		}, 100); // Debounce time
	});
});

</script>
